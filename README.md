## 1. 계획(Planning)
- **개요**
    - 2학년 1학기 자료구조 개인 과제
    - BST 기반 사전 프로그램 개선

- **개발 환경**
    - C
    - Ubuntu Linux
    - Vim

## 2. 요구사항 분석(Requirement Analysis)
### 2.1. 기존 프로그램 분석
- 프로그램을 수정하기에 앞서, 전체적인 구조와 각 함수의 구현 의도를 먼저 분석하였습니다.
- 주요 기능 단위로 코드를 분해하여 이해하였으며, 함수별 구조와 기능, 사용 위치를 정리하였습니다.

---

| 함수 원형 | `int compare(element e1, element e2);`                                          |
| :---- | :------------------------------------------------------------------------------ |
| 기능    | 두 개의 element 구조체를 키 필드(word) 기준으로 비교<br>e1.word < e2.word 이면 –1, 같으면 0, 크면 1 반환 |
| 사용 위치 | 트리 탐색(search), 삽입(insert_node), 삭제(delete_node) 시 노드 간 순서 비교에 사용                |

| 함수 원형 | `void display(TreeNode *p);`                                                              |
| :---- | :---------------------------------------------------------------------------------------- |
| 기능    | 중위 순회(in-order) 방식으로 이진 탐색 트리를 출력<br>왼쪽 하위트리, 노드(word:meaning), 오른쪽 하위트리 순으로 괄호로 묶어 재귀 출력 |
| 사용 위치 | main()의 'p' 명령 처리 시 전체 트리 구조 출력에 호출                                                       |

| 함수 원형 | `TreeNode *search(TreeNode *root, element key);`                            |
| :---- | :-------------------------------------------------------------------------- |
| 기능    | 루트부터 시작해 키(word)를 비교하며 이진 탐색 트리에서 해당 노드를 찾음<br>찾으면 해당 노드 포인터, 못 찾으면 NULL 반환 |
| 사용 위치 | main()의 's' 명령 처리 시 단어 검색 기능에 호출                                            |

---

| 함수 원형 | `TreeNode *new_node(element item);`                             |
| :---- | :-------------------------------------------------------------- |
| 기능    | 힙에 TreeNode 할당 후 item을 키로 저장하고 좌·우 자식 포인터를 NULL로 초기화<br>새 노드 생성 |
| 사용 위치 | insert_node()에서 빈 위치에 새 노드를 삽입할 때 호출                            |

| 함수 원형 | `TreeNode *insert_node(TreeNode *node, element key);`                          |
| :---- | :----------------------------------------------------------------------------- |
| 기능    | 주어진 서브트리(node)에 key를 삽입하고, 새로운 루트 포인터 반환<br>재귀 호출을 통해 왼쪽/오른쪽 자식으로 내려가 새 노드를 배치 |
| 사용 위치 | main()의 'i' 명령 처리 시 삽입 기능에 직접 호출<br>내부적으로 new_node()와 재귀적으로 자기 자신을 호출          |

| 함수 원형 | `TreeNode *min_value_node(TreeNode *node);`                  |
| :---- | :----------------------------------------------------------- |
| 기능    | 주어진 서브트리에서 가장 작은(왼쪽 끝) 노드를 찾아 반환                             |
| 사용 위치 | delete_node()에서 두 자식이 있는 노드 삭제 시 후속자(successor) 노드를 찾기 위해 호출 |

---

| 함수 원형 | `TreeNode *delete_node(TreeNode *root, element key);`                         |
| ----- | ----------------------------------------------------------------------------- |
| 기능    | 이진 탐색 트리에서 key와 일치하는 노드를 삭제<br>자식 0개/1개/2개에 따라 적절히 트리 구조를 재구성하여 새로운 루트 반환     |
| 사용 위치 | main()의 'd' 명령 처리 시 삭제 기능에 호출<br>내부적으로 compare(), min_value_node(), 재귀 호출을 사용 |

| 함수 원형 | `void help();`                                  |
| ----- | ----------------------------------------------- |
| 기능    | 사용자에게 입력 가능한 명령 목록(i, d, s, p, q)을 안내하는 프롬프트 출력 |
| 사용 위치 | main() 반복 루프 시작 시마다 호출되어 사용자 안내 역할 수행           |

| 함수 원형 | `int main(void);`                                                                                     |
| ----- | ----------------------------------------------------------------------------------------------------- |
| 기능    | 프로그램 진입점(entry point)<br>help() 호출 후 getchar()로 명령을 받아 삽입/삭제/검색/출력/종료 기능 수행<br>루프 종료 시 0 반환하며 프로그램 종료 |
| 사용 위치 | 프로그램 시작 시 자동 실행                                                                                       |

### 2.2. 문제점 식별 및 코드 수정
| #   | 문제점         | 식별 방법                                                                                                 |
| --- | ----------- | ----------------------------------------------------------------------------------------------------- |
| 1   | gets() 사용   | 컴파일 시 에러 경고  <br>→ C11 표준에서 제거된 gets() 함수  <br>(버퍼 오버플로우 위험 및 보안 취약점)                                 |
| 2   | 중복 단어 처리 누락 | cmd-list.txt의 중복 삽입 시나리오(i 6 7777) 실행 후,  <br>“이미 존재” 메시지 없이 조용히 무시되는 현상                              |
| 3   | 검색 결과 빈 출력  | cmd-list.txt에서 s 4 명령 실행 후,  <br>기대한 의미(4444) 대신 빈 문자열이 출력되는 현상  <br>→ 코드 중 e.meaning을 잘못 출력하고 있음을 추적 |
| 4   | 삭제 로직 오동작   | d 0 명령 실행 후,  <br>트리 구조가 어긋나면서 루트가 의도치 않게 삭제되는 현상  <br>→ 두 개의 독립 if 분기문이 잘못 연결된 것을 발견                 |
| 5   | 메모리 누수      | 할당된 노드들이 해제되지 않음  <br>→ 누수(leak) 의심                                                                   |

## 3. 설계(Design)
### 3.1. 모듈화
| 파일       | 기능                                       |
| -------- | ---------------------------------------- |
| bst.h    | 이진 탐색 트리의 구조체 정의와<br>주요 함수 시그니처 선언       |
| bst.c    | 삽입·탐색·삭제·출력·메모리 해제 등<br>BST 핵심 로직 구현     |
| main.c   | 사용자 메뉴 입력 처리 및<br>bst 모듈 호출을 통한 사전 기능 제공 |
| Makefile | main.c·bst.c 컴파일부터<br>dic 실행 파일 생성까지 자동화 |
- 모듈화가 필수적인 규모는 아니지만, 가독성을 높이고 유지보수 및 테스트를 용이하게 하기 위해 간단한 수준의 모듈화를 적용 하였습니다.
- 이를 통해 코드 구조를 보다 명확하게 하였습니다.


## 4. 구현(Implementation)
### 4.1. 코드 수정 내역표
| 제시된 프로그램에서  <br>확인된 문제점 | 보완된 프로그램  <br>수정 내역                                           | 보완된 프로그램  <br>시작 줄 번호               | 보완된 프로그램  <br>끝 줄 번호                |
| ----------------------- | ------------------------------------------------------------- | ----------------------------------- | ----------------------------------- |
| gets() 사용               | gets()  <br>→ fgets(...); strip_newline()로 대체                 | main.c:27<br>main.c:43<br>main.c:56 | main.c:32<br>main.c:44<br>main.c:57 |
| 중복 단어 처리 누락             | if (search_node(root, e))  <br>printf("이미 존재하는 단어입니다.\n"); 추가 | main.c:34                           | main.c:35                           |
| 검색 결과 빈 출력              | printf("의미:%s\n", tmp->key.meaning);로 변경                      | main.c:60                           | main.c:61                           |
| 삭제 로직 오동작               | 두 번째 if  <br>→ else if로 분기 처리                                 | bst.c:69                            | bst.c:70                            |
| 메모리 누수                  | free_tree(root); 호출 추가                                        | main.c:82<br>(bst.c:105)            | main.c:82  <br>(bst.c:111)          |

## 5. 테스트(Testing)
### 5.1. 실행/입력 기능 검증
![|400](https://imgur.com/Fu4J8oA.png)
- cmd-list.txt를 기준으로 각 명령 실행 후 출력을 확인하며 기능을 테스트하였습니다.
- 삽입 시 루트를 기준으로 적절한 위치에 노드를 추가합니다.
- 모든 노드는 유일한 키를 갖기 때문에 중복 단어는 허용되지 않습니다.

### 5.2. 탐색 기능 검증
![|400](https://imgur.com/zPM3Ei7.png)
- cmd-list.txt를 기준으로 각 명령 실행 후 출력을 확인하며 기능을 테스트하였습니다.
- 정상적인 탐색과 없는 키에 대한 탐색 실패를 확인할 수 있습니다.
- 단순 탐색이기에 원본 데이터에 영향을 주지 않습니다.

### 5.3. 삭제 기능 검증/종료
![|400](https://imgur.com/NwG8hgP.png)
- cmd-list.txt를 기준으로 각 명령 실행 후 출력을 확인하며 기능을 테스트하였습니다.
- 정상적인 삭제와 없는 키에 대한 삭제 실패를 확인할 수 있습니다.
- 없는 키에 대한 삭제는 당연히 원본 데이터에 영향을 주지 않습니다.

## 6. 추가 학습
### 6.1. 셸 입력 리다이렉션
- 이번 학기에 함께 수강 중인 유닉스기초 강의에서 학습한 셸 입력 리다이렉션 기능을 활용하였습니다.
- `./dic < cmd-list.txt`
- 이를 통해 명령어 파일(cmd-list.txt)을 표준 입력으로 연결하여, 반복적인 테스트 과정을 자동화할 수 있음을 확인하였습니다.
- 이 방식은 테스트의 일관성을 유지하고 디버깅 시간을 단축하는 데에도 효과적이었습니다.

### 6.2. C 프로파일링
- **프로파일링의 목적**
	- 성능 병목 지점 파악 (시간, 메모리)
	- 함수별 실행 시간 측정
	- 코드 최적화 대상 찾기

- **GNU gprof**
	- GCC에서 컴파일한 C 프로그램 분석
	- 함수 호출 횟수, 실행 시간 등을 보고서로 제공

#### (1) 메모리 누수 탐지 도구
- 동적 할당 해제 코드 유무로 메모리 누수를 판단하는 데 한계를 느껴, 보다 신뢰할 수 있는 기술적 방법을 찾아보았습니다.
- gcc AddressSanitizer를 활용하여 -fsanitize=address 옵션을 추가해 컴파일하고 실행 시 메모리 오류를 감지
- Valgrind 도구로 정밀한 누수 정보를 확인: `valgrind --leak-check=full --show-leak-kinds=all ./dic < cmd-list.txt`

### 6.3. SFTP 명령어
- 서버 환경 실습을 위한 SFTP(Secure File Transfer Protocol) 명령어입니다.
- `pwd/lpwd`: 현재 서버/로컬 디렉터리 확인
- `ls/lls`: 현재 서버/로컬 디렉터리 확인
- `cd/lcd`: 서버/로컬 디렉터리 변경
- `get [-r] (name)`: `파일[디렉터리]`을 서버에서 로컬로
- `put [-r] (name)`: `파일[디렉터리]`을 로컬에서 서버로